function [dataStruct] = mwspeedmmData(binsize, cutoffTime, varargin)

% FIXME - 2011-05-09 CJC Need to update usage info/help for HELPER FUNCTION

%MWSPEEDMM    Determine the time-dependent mean of means speed of a population of worms analyzed by the Goodman Lab multi-worm tracker.
%   FORMAT: mwspeedmm(binsize, cutoffTime, firstTracksFile.mat, secondTracksFile.mat,..., NthTracksFile.mat)
%       where 
%       - binsize: The speed data from every track (in all of the input
%         .mat files) is broken into even-sized chunks of time
%         corresponding to when that track existed.  Binsize describes the
%         length, in seconds, of those time chunks.
%       - cutoffTime: Speed data captured at or after this time (in
%         seconds) is ignored.  (Handles cases where recording continued
%         after desired stop time.)  Use large value (like inf even) to
%         keep all data.
%       - *TracksFile.mat's are the names (with paths) of Matlab ".mat"
%         files generated by the Goodman Lab multi-worm tracker that
%         contain the Goodman Lab-defined "Tracks" structure.  To be used
%         by mwspeedmm, the Tracks structures in the .mat files should have
%         been analyzed to contain fields called Speed and Time for each
%         individual track.
%       and
%       - "ss" is the list of speed measurements from all of the worm
%         tracks listed in the input TracksFiles.mat, in monotonically
%         non-decreasing time order.
%       - "tt" is the list of time points associated with each speed
%         measurement in ss.
%
%   Discussion:
%       For each track represented in a particular time bin, "mwspeedmm"
%       finds the mean value of each track while it existed and
%       calculates the mean of those means as the "mean of means" value
%       for that time bin.  In addition, "mwspeedmm" also calculates a
%       WEIGHTED mean of means, giving proportional influence to each
%       track based on how long the track existed during that time bin
%       compared to the other tracks represented in the time bin.  For the
%       "plain old" mean-of-means, the standard deviation and population
%       size for each bin only considers the number of tracks.  For the
%       WEIGHTED population size we take the total number of data points
%       for all tracks in the bin; likewise, for the WEIGHTED standard
%       deviation we represent each mean value as a repeated series of that
%       mean value, the quantity of which corresponding to the number of
%       data points used to calculate the mean value.  For example, a track
%       comprised of four data points with a mean value of 0.2 would be
%       represented as [0.2 0.2 0.2 0.2], while a track with only two data
%       points but a mean value of 0.15 would be represented as [0.15 0.15] 
%       for the WEIGHTED standard deviation calculation.
% 
%   example:
%       [ss,tt] = mwspeedmm(60, 960 ...
%           'G:\Data\Chris\2009_04_20\N2_day1.mat',...
%           'G:\Data\Chris\2009_04_21\N2_day2.mat',...
%           'G:\Data\Chris\2009_04_22\N2_day3.mat');
%       would combine all the multiple worm track recorded in those three
%       days' .mat files (each containing the necessary analyzed "Tracks"
%       structure into a single set of data, then find the mean speed
%       values for each 60-second period from the start of the first worm's
%       track through the end of the last worm's track.  The function
%       returns the speed and time values in ss and tt.  Speed data
%       recorded after 960 seconds into each recording is ignored.
%
% - Christopher J. Cronin  (cjc@caltech.edu)
%   California Institute of Technology
%   Sternberg Lab
%   Pasadena, CA  USA
%   April 22, 2009

% Created for speed decay vs time work by Meenakshi Doma.


% Initialize intermidiate/output vectors
tt = [];
ss = [];
tcell = {};
scell = {};

% Loop through each input .mat file
for j = 1:nargin-2
    t = [];
    s = [];
    
    % Place I/O stuff in try/catch statement for safety
    try
        load(varargin{j});
        
        if exist('Tracks', 'var') == 1  % Only care if Tracks is in the loaded .mat file
            for i = 1:numel(Tracks)
                % Trim off speed values recorded after cut-off time
                abridgedTime    = Tracks(i).Time;
                abridgedSpeed   = Tracks(i).Speed;
                abridgedSpeed   = abridgedSpeed(abridgedTime < cutoffTime);
                abridgedTime    = abridgedTime( abridgedTime < cutoffTime);
                
                t = [t abridgedTime];
                s = [s abridgedSpeed];

                % Collect time and speed vectors for each individual track
                % into time and speed cell arrays
                tcell{numel(tcell)+1} = abridgedTime;
                scell{numel(scell)+1} = abridgedSpeed;
                
            end
        else
            fprintf(1, 'No ''Tracks'' in %s.  Skipping...', varargin{j});
        end
        clear Tracks
        
        % Combine time and speed vectors
        tt = [tt, t];
        ss = [ss, s];
        
    catch ME
        fprintf(1, '%s\n', ME.message);
    end
    
end


% Sort speed data against by time
[tt, ix] = sort(tt);
ss = ss(ix);

% figure; plot(tt,ss, 'ro');

% Create time bins
ttt = tt/binsize;
ttt = floor(ttt)*binsize;
ttt = ttt+binsize;
bins = unique(ttt);

%------------------------------------------------------------------------
% Calculate statistics about sample sizes at each timepoint
uniqueTimepoints = unique(tt);
timepointsamplesizes = NaN*ones(size(uniqueTimepoints));
for k = 1:numel(uniqueTimepoints)
    timepointsamplesizes(k) = sum(tt == uniqueTimepoints(k));
end

% Combine timepoints into bins
meanBinnedTimepointSampleSize   = NaN*ones(size(bins));
maxBinnedTimepointSampleSize    = NaN*ones(size(bins));
minBinnedTimepointSampleSize    = NaN*ones(size(bins));

for k = 1:numel(bins)
    % figure out statistics for timepoints in each bin
    if k == 1
        meanBinnedTimepointSampleSize(k) = mean(timepointsamplesizes( uniqueTimepoints < bins(k)  ));
         maxBinnedTimepointSampleSize(k) =  max(timepointsamplesizes( uniqueTimepoints < bins(k)  ));
         minBinnedTimepointSampleSize(k) =  min(timepointsamplesizes( uniqueTimepoints < bins(k)  ));
    elseif k == numel(bins)
        meanBinnedTimepointSampleSize(k) = mean(timepointsamplesizes( uniqueTimepoints >=bins(k-1)));
         maxBinnedTimepointSampleSize(k) =  max(timepointsamplesizes( uniqueTimepoints >=bins(k-1)));
         minBinnedTimepointSampleSize(k) =  min(timepointsamplesizes( uniqueTimepoints >=bins(k-1)));
    else
        meanBinnedTimepointSampleSize(k) = mean(timepointsamplesizes((uniqueTimepoints >=bins(k-1)) & ...
                                                                     (uniqueTimepoints < bins(k)) ));
         maxBinnedTimepointSampleSize(k) =  max(timepointsamplesizes((uniqueTimepoints >=bins(k-1)) & ...
                                                                     (uniqueTimepoints < bins(k)) ));
         minBinnedTimepointSampleSize(k) =  min(timepointsamplesizes((uniqueTimepoints >=bins(k-1)) & ...
                                                                     (uniqueTimepoints < bins(k)) ));
    end
    
end
%------------------------------------------------------------------------

% Create and populate 3D matrix of mean speed data, with populations and stds
meandata = NaN*ones(numel(scell), numel(bins), 3);
startstop = NaN*ones(numel(scell), numel(bins), 2);
% Where,
% dimension 1: tracks
% dimension 2: time bins
% dimension 3: mean speeds, 
%               n (number of data points for track in bin),
%                std  (of data points for track in bin 


for i = 1:numel(scell)
    % Temporary vector identifying speeds/times with time bins
    tttcell = tcell{i}/binsize;
    tttcell = floor(tttcell)*binsize;
    tttcell = tttcell+binsize;
    
    for k = 1:numel(bins)
        meandata(i,k,1) =  mean(scell{i}(tttcell==bins(k)));
        meandata(i,k,2) = numel(scell{i}(tttcell==bins(k)));
        meandata(i,k,3) =   std(scell{i}(tttcell==bins(k)));
        
        if (any(~isnan(tcell{i}(tttcell==bins(k)))))
            startstop(i,k,1) =  min(tcell{i}(tttcell==bins(k)));
            startstop(i,k,2) =  max(tcell{i}(tttcell==bins(k)));
        end
    end
end


% Plain old mean speeds per bin
po_mean = nanmean(meandata(:,:,1));
 po_std =  nanstd(meandata(:,:,1));
   po_n = sum(~isnan(meandata(:,:,1)));

% Weighted Mean
weightedmean = nansum(meandata(:,:,1).*meandata(:,:,2))./nansum(meandata(:,:,2));
weightedstd = NaN*ones(size(bins)); % (see calculation below)
weightedn = NaN*ones(size(bins));   % Number of data points in bin
for k = 1:numel(bins)
    fauxspeed = [];
    for i = 1:size(meandata,1)
        if ~isnan(meandata(i,k,1))
            fauxspeed = [fauxspeed, meandata(i,k,1)*ones(1,meandata(i,k,2))];
        end
    end
    weightedstd(k) = std(fauxspeed);
    weightedn(k) = numel(fauxspeed);
end



% Format output
dataStruct.po_mean      = po_mean;
dataStruct.po_std       = po_std;
dataStruct.po_n         = po_n;
dataStruct.bins         = bins;
dataStruct.meandata     = meandata;
dataStruct.weightedmean = weightedmean;
dataStruct.weightedstd  = weightedstd;
dataStruct.weightedn    = weightedn;
dataStruct.ss           = ss;
dataStruct.tt           = tt;

