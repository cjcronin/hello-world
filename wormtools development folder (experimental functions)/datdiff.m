function [numDiffPixels] = datdiff(datfile, diffthreshold)

%DATDIFF    Counts the number of pixels changed between successive frames in a .dat file
%   FORMAT: datdiff(datFileName, diffthreshold);
%       where 
%       - "datFileName" is the name (with path, if necessary) of a 
%           .dat file created by DigiRecognizer
%       - "diffthreshold" is a threshold value [0-254] describing how
%           much a pixel must change in intensity to be considered
%           'changed' between successive frames.
%
%   example:  [numDiffPix] = datdiff('D:\Chris\worm6.dat', 10);
%
%   The .dat files generated by DigiRecognizer are structured as a header
%   describing the file's image dimensions (e.g. 640 pixels wide x 480
%   pixels tall), then a repeating pattern of timestamp (when an image was
%   captured) and image.  The 'image' is a series of [width x height]
%   integers describing the intensity of each of the pixels in the image.
%   Values range from 0 to 255 (where 0 is black, 255 is white) (...an
%   8-bit image).  
%   
%   This function compares successive images from the supplied .dat file.
%   For each successive pair the function subtracts the first image from
%   the second, takes the absolute values of the differences (to just look
%   at 'change' rather than light->dark or dark->light), thresholds to
%   see which pixels changed 'enough' -- that is, more than the
%   'diffthreshold' -- to be considered changed, then counts how many.  
%   The changed-pixel count is recorded for each pair of frames resulting
%   in NumFrames-1 values. 
%   
% Christopher J. Cronin
% Sternberg Lab
% California Institute of Technology
% Pasadena  CA  91125
% cjc@caltech.edu
% January 9, 2013
   

% based on:
% function [] = makemovie2(datfile, imscale, compression)



% Error checking
if nargin < 1
    error('Not enough input arguments')
end

% Set default difference threshold
if nargin < 2
    diffthreshold = 0;
end


% Open .dat file for reading
fid = fopen(datfile);
if (fid == -1)
    error(['Can''t open file "%s" for reading.\n' ...
        ' File may not exist or you may not have read permission.'], ...
        datfile);
end


% -----------------------------------------------------
% Get ready...

% Find image size
sizeX = fread(fid,1,'uint32');
sizeY = fread(fid,1,'uint32');

% Determine number of frames:  
headerSize = 2*4;  % two 4 byte (uint) values

timestampSize = 8;  % one 8 byte (double) value
imageSize = (sizeX * sizeY) * 1;  % 640*480 single byte (uchar) values 
merSize = timestampSize + imageSize;    % size of image plus header info...

fseek(fid, 0, 'eof');
position = ftell(fid);
numframes = (position - headerSize)/merSize;

% Calculate recording duration and framerate
fseek(fid, -merSize, 'eof');
timeBeforeLastImage = fread(fid, 1, 'double'); 

fseek(fid, headerSize, 'bof');
timeBeforeFirstImage = fread(fid, 1, 'double');

% Read in first image to find scaling limits
Im = fread(fid,[sizeX sizeY],'uchar');
clim = [min(min(Im)), max(max(Im))];

% Reset read position in .dat file to just before first timestamp
fseek(fid, headerSize, 'bof');


dursec = timeBeforeLastImage - timeBeforeFirstImage; %But this is for n-1 images...
dursec = (dursec * numframes)/(numframes-1);    % Corrected for n frames
fpsval = numframes/dursec;


% -----------------------------------------------------
% Go...

fig = figure;

% Set up vector to hold difference counts
numDiffPixels = NaN * ones(numframes-1, 1);
    

timestamp = fread(fid,1,'double');
Im0 = fread(fid,[sizeX sizeY],'uchar');
Im0=Im0';     % Transpose if we want to display



% Work through .dat file counting different pixels
for i = 1:numframes-1 
    timestamp = fread(fid,1,'double');
    Im1 = fread(fid,[sizeX sizeY],'uchar');
    Im1=Im1';     % Transpose if we want to display

    % Image difference
    idiff = Im1 - Im0;
    
    % Absolute value (just consider 'change', not which way)
    idiff = abs(idiff);


    
    % Assemble image for display
    chg = idiff > diffthreshold;
    
    % Make changed pixels red
    r = Im1;
    g = Im1;
    b = Im1;
    r(chg) = 255;
    g(chg) =   0;
    b(chg) =   0;
    img = cat(3, r, g, b);

    

    % Reshape to column vector
    idiff = reshape(idiff, numel(idiff), 1);
    
    % Sort
%     absidiff = sort(abs(idiff));

    % Record
    numDiffPixels(i) = sum(idiff > diffthreshold);

    % User feedback...
    fprintf(1, [int2str(i) '\t']);
    if mod(i, 10) == 0
        fprintf('\n');
    end
    
    
    % Display difference
    h = image(img/255); 
    colormap gray;
    set(h, 'EraseMode', 'none');    % Not sure if we need this
    pause(0.001);    % Time to display image
    
    
    
    % Make new image into old base image
    Im0 = Im1;
    
end % for i

fprintf(1, '\n');


% Clean up! Clean up! (Muy Importante!!!)
fclose(fid);


