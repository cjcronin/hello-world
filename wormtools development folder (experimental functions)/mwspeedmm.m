function [ss,tt] = mwspeedmm(binsize, cutoffTime, varargin)

% MWSPEEDMM    Determine the time-dependent mean of mean speeds 
%              for one or more populations of worms analyzed by the 
%              Goodman Lab multi-worm tracker.
%
%   FORMAT: [ss, tt] = mwspeedmm(binsize, cutoffTime, PopulationTrackFile[s])
%           
%       where 
%       - binsize: The speed data from every track (in all of the input
%         .mat files) is binned into even-sized chunks of time
%         corresponding to when that track existed.  Binsize describes the
%         length, in seconds, of those time chunks.
%       - cutoffTime: Speed data captured at or after this time (in
%         seconds) is ignored.  This handles cases where recording
%         continued after desired stop time.  Use a large value (like 
%         'inf' [infinity] even) to consider all data from each track file.
%       - PopulationTrackFiles are the names (with paths) of Matlab ".mat"
%         files generated by the Goodman Lab multi-worm tracker that
%         contain the Goodman Lab-defined "Tracks" structure.  To be used
%         by mwspeedmm, the Tracks structures in the .mat files must have
%         been 'analyzed' to contain fields called 'Speed' and 'Time' for 
%         each individual track.
%           -- A list of track files for a population should be
%              surrounded by curly braces -- i.e. {}'s.
%           -- When comparing multiple populations, specify multiple lists,
%              each surrounded by curly braces, with each curly-brace-
%              surrounded list separated by a comma.
%           -- Note: A list without braces is interpreted as representing
%              one single population.
%       and
%       - "ss" is a cell array containing lists of speed measurements (one
%         list per population) from all of the tracks listed in the input
%         PopulationTrackFiles.  Speed measurements are sorted into
%         monotonically non-decreasing time order. 
%       - "tt" is a cell array containing the lists of time points
%         associated with each speed measurement in ss.
%
%   Discussion:
%       For each track represented in a particular time bin, "mwspeedmm"
%       finds the mean value of each track while it existed in that time 
%       bin and calculates the mean of those means as the "mean of means" 
%       value for the time bin.  In addition, "mwspeedmm" also calculates 
%       a WEIGHTED mean of means, giving proportional influence to each
%       track based on how long the track existed during that time bin
%       compared to the other tracks represented in the time bin.  For the
%       "plain old" mean-of-means, the standard deviation and population
%       size for each bin only considers the number of tracks.  For the
%       WEIGHTED population size we take the total number of data points
%       for all tracks in the bin; likewise, for the WEIGHTED standard
%       deviation we represent each mean value as a repeated series of that
%       mean value, the quantity of which corresponding to the number of
%       data points used to calculate the mean value.  For example, a track
%       comprised of four data points with a mean value of 0.2 would be
%       represented as [0.2 0.2 0.2 0.2], while a track with only two data
%       points but a mean value of 0.15 would be represented as [0.15 0.15] 
%       for the WEIGHTED standard deviation calculation.
% 
%   example:
%       % Single population:
%       [ss,tt] = mwspeedmm(60, 960 ...
%          {'G:\Data\Chris\2009_04_20\N2_day1.mat',...
%           'G:\Data\Chris\2009_04_21\N2_day2.mat',...
%           'G:\Data\Chris\2009_04_22\N2_day3.mat'});
%       would combine all the multiple worm track recorded in those three
%       days' .mat files (each containing the necessary analyzed "Tracks"
%       structure into a single set of data, then find the mean speed
%       values for each 60-second period from the start of the first worm's
%       track through the end of the last worm's track.  The function
%       returns the speed and time values in ss and tt.  Speed data
%       recorded after 960 seconds into each recording is ignored.
%
%       % Multiple populations:
%       mwspeedmm(120, inf ...
%          {'G:\Data\2011_05_18\N2_day1.mat', ...       % first population
%           'G:\Data\2011_05_19\N2_day2.mat', ...
%           'G:\Data\2011_05_20\N2_day3.mat'},...
%          {'D:\unc\uncA.mat', 'D:\unc\uncB.mat'});     % second population
%       would combine the three days of "N2" recordings and compare them
%       against the two combined "unc" recordings.  Data would be binned
%       in two-minute blocks (120 seconds = 2 minutes).  All data (from
%       the beginning to "infinity" --> inf) is considered.
%
%
% - Christopher J. Cronin  (cjc@caltech.edu)
%   California Institute of Technology
%   Sternberg Lab
%   Pasadena, CA  USA
%   April 22, 2009
%   updated: May 23, 2011 - C J Cronin
%   [plus grammer corrections and repository commit 9/21/2011 - C J Cronin]

% Created for speed decay vs time work by Meenakshi Doma.


% Figure out whether we are comparing populations or looking at a single
% population
numCellArrays = 0;
for i = 1:numel(varargin)
    if (iscellstr(varargin{i}))
        numCellArrays = numCellArrays + 1;
    end
end

% Error checking
if ~( (numCellArrays == 0) || (numCellArrays == numel(varargin)) )
    error('Input folder names must be presented as Cell Arrays {...}, or as individual folders -- Not A Mix!');
end


if (numCellArrays == 0)
    population = {varargin};
else
    population = varargin;
end


% Prompt for legend
legendtext = cell(size(population));
for i = 1:numel(population)
    legendtext{i} = ['Population ' int2str(i)];
end
legendtext = promptforlegend(legendtext{:});
if isnan(legendtext)    % i.e. if user hit 'Cancel'
    ss = NaN;
    tt = NaN;
    return;
end



% Initialize data holders
blankDataHolder = NaN*ones(ceil(cutoffTime/binsize), numel(population));
po_mean         = blankDataHolder;
po_std          = blankDataHolder;
po_n            = blankDataHolder;
bins            = blankDataHolder;
weightedmean    = blankDataHolder;
weightedstd     = blankDataHolder;
weightedn       = blankDataHolder;

meandata    = [];   % FIXME: Decide how to best handle this data

ss  = cell(1,numel(population));   % Cell array
tt  = cell(1,numel(population));   % Cell array


for i = 1:numel(population)
    
    % Collect data for plotting
    [dataStruct] = collectData(binsize, cutoffTime, population{i}{:});
    % [dataStruct] = collectData(binsize, cutoffTime, varargin{:});
    % [dataStruct] = mwspeedmmData(binsize, cutoffTime, varargin{:});
    
    % Extract data
    po_mean(:,i)        = (dataStruct.po_mean)';
    po_std(:,i)         = (dataStruct.po_std)';
    po_n(:,i)           = (dataStruct.po_n)';
    bins(:,i)           = (dataStruct.bins)';
    weightedmean(:,i)   = (dataStruct.weightedmean)';
    weightedstd(:,i)    = (dataStruct.weightedstd)';
    weightedn(:,i)      = (dataStruct.weightedn)';

    meandata        = [dataStruct.meandata];        % <---FIXME

    ss{i}           = dataStruct.ss;
    tt{i}           = dataStruct.tt;
    
end



%----PLOT Plain Old-SEM------------------------------------------------
h = plotGeneric('errorbar', bins, po_mean, po_std./sqrt(po_n), po_n, ...
               ['Mean speed over prior ' num2str(binsize) ' seconds, +/- 1 SEM'],...
               legendtext);
           
%----PLOT Plain Old-SEM------------------------------------------------



%----PLOT Plain Old-STD------------------------------------------------
h = plotGeneric('errorbar', bins, po_mean, po_std, po_n, ...
               ['Mean speed over prior ' num2str(binsize) ' seconds, +/- 1 STD'],...
               legendtext);
           
%----PLOT Plain Old-STD------------------------------------------------



%----PLOT Plain Old------------------------------------------------
h = plotGeneric('plot', bins, po_mean, po_std, po_n, ...
               ['Mean speed over prior ' num2str(binsize) ' seconds'],...
               legendtext);
           
%----PLOT Plain Old------------------------------------------------



%----PLOT Plain Old-STD with individual track means----------------
if numel(population) == 1
    h = plotGeneric('errorbar', bins, po_mean, po_std, po_n, ...
        ['Mean speed over prior ' num2str(binsize) ' seconds, +/- 1 STD (with track means)'],...
               legendtext);
           
    % Add individual mean values
    axes(ancestor(h, 'axes'));
    hold on;
    for g = 1:numel(bins)
        plot(bins(g), meandata(:,g,1), 'o');
    end
    hold off
end


%----PLOT Plain Old-STD with individual track means----------------



%----PLOT WEIGHTED MEAN--------------------------------------------
h = plotGeneric('plot', bins, weightedmean, [], po_n, ...
               ['WEIGHTED Mean speed over prior ' num2str(binsize) ' seconds'],...
               legendtext);
           
%----PLOT WEIGHTED MEAN--------------------------------------------



%----PLOT WEIGHTED MEAN - WEIGHTED SEM-----------------------------
h = plotGeneric('errorbar', bins, weightedmean, weightedstd./sqrt(weightedn), po_n, ...
               ['WEIGHTED Mean speed over prior ' num2str(binsize) ' seconds, +/- 1 SEM'],...
               legendtext);
           
%----PLOT WEIGHTED MEAN - WEIGHTED SEM-----------------------------



%----PLOT WEIGHTED MEAN - WEIGHTED STD-----------------------------
h = plotGeneric('errorbar', bins, weightedmean, weightedstd, po_n, ...
               ['WEIGHTED Mean speed over prior ' num2str(binsize) ' seconds, +/- 1 STD'],...
               legendtext);
           
%----PLOT WEIGHTED MEAN - WEIGHTED STD-----------------------------

return;



%--------------------------------------------------------------------
%--------------------------------------------------------------------
%--------------------------------------------------------------------




function h = plotGeneric(plotStyle, X, Y, EBAR, N, TITLETEXT, LEGENDTEXT, LINECOLOR)

% FIXME Add usage information

% Define linewidth for plot
linewdth = 2;

% Handle case where LINECOLOR isn't provided in function call
if exist('LINECOLOR', 'var') == 0
    LINECOLOR = [];
end

%----PLOT Generic------------------------------------------------
figure; 
subplot(5,1, 1:4); 

% h = errorbar(bins, po_mean, po_std./sqrt(po_n), 'bo-');
if strcmp(plotStyle, 'errorbar')
    h = eval(['errorbar(X, Y, EBAR, ''' LINECOLOR 'o-'');']);
elseif strcmp(plotStyle, 'plot')
    h = eval(['plot(X, Y, ''' LINECOLOR 'o-'');']);
else
    error('plotStyle must be ''errorbar'' or ''plot''!');
end

set(h, 'LineWidth', linewdth);
currentXLimits = get(gca, 'XLim');
currentYLimits = get(gca, 'YLim');
set(gca, 'XLim', [0 currentXLimits(2)]);
set(gca, 'YLim', [0 currentYLimits(2)]);
ylabel('Speed  [mm/sec]', 'FontWeight', 'bold');
title(TITLETEXT, 'FontWeight', 'bold');
% legendtext = ['Mean speed over prior ' num2str(binsize) ' seconds, +/- 1 SEM'];
legend(LEGENDTEXT);
set(gca, 'FontWeight', 'bold');


subplot(5,1,5); 
eval(['plot(X, N, ''' LINECOLOR '.-'')']);
% plot(bins, po_n, 'b.-');

set(gca, 'XLim', [0 currentXLimits(2)]);
xlabel('Time  [sec]', 'FontWeight', 'bold');
ylabel({'# tracks'; 'per time period'}, 'FontWeight', 'bold');


% Code to format plots for landscape output
set(gcf, 'PaperOrientation', 'Landscape');
set(gcf, 'PaperPosition', [0.25  0.25  10.5  8.0]);
set(gca, 'FontWeight', 'bold');

% To ensure color plot from Wormwriter Color
%   or grayscale plot from Wormwriter2
%   (was getting blank plots from ...2 and ...Color on 6/25/03
%   when plots were automatically setting to 'renderer' = 'zbuffer')
%   (Plots were also blank with 'renderer' = 'opengl'.)
set(gcf, 'Renderer', 'painters');
%----PLOT Generic------------------------------------------------

return;



%--------------------------------------------------------------------
%--------------------------------------------------------------------
%--------------------------------------------------------------------




function [dataStruct] = collectData(binsize, cutoffTime, varargin)

% FIXME - 2011-05-09 CJC Need to update usage info/help for HELPER FUNCTION

%MWSPEEDMM    Determine the time-dependent mean of means speed of a population of worms analyzed by the Goodman Lab multi-worm tracker.
%   FORMAT: mwspeedmm(binsize, cutoffTime, firstTracksFile.mat, secondTracksFile.mat,..., NthTracksFile.mat)
%       where 
%       - binsize: The speed data from every track (in all of the input
%         .mat files) is broken into even-sized chunks of time
%         corresponding to when that track existed.  Binsize describes the
%         length, in seconds, of those time chunks.
%       - cutoffTime: Speed data captured at or after this time (in
%         seconds) is ignored.  (Handles cases where recording continued
%         after desired stop time.)  Use large value (like inf even) to
%         keep all data.
%       - *TracksFile.mat's are the names (with paths) of Matlab ".mat"
%         files generated by the Goodman Lab multi-worm tracker that
%         contain the Goodman Lab-defined "Tracks" structure.  To be used
%         by mwspeedmm, the Tracks structures in the .mat files should have
%         been analyzed to contain fields called Speed and Time for each
%         individual track.
%       and
%       - "ss" is the list of speed measurements from all of the worm
%         tracks listed in the input TracksFiles.mat, in monotonically
%         non-decreasing time order.
%       - "tt" is the list of time points associated with each speed
%         measurement in ss.
%
%   Discussion:
%       For each track represented in a particular time bin, "mwspeedmm"
%       finds the mean value of each track while it existed and
%       calculates the mean of those means as the "mean of means" value
%       for that time bin.  In addition, "mwspeedmm" also calculates a
%       WEIGHTED mean of means, giving proportional influence to each
%       track based on how long the track existed during that time bin
%       compared to the other tracks represented in the time bin.  For the
%       "plain old" mean-of-means, the standard deviation and population
%       size for each bin only considers the number of tracks.  For the
%       WEIGHTED population size we take the total number of data points
%       for all tracks in the bin; likewise, for the WEIGHTED standard
%       deviation we represent each mean value as a repeated series of that
%       mean value, the quantity of which corresponding to the number of
%       data points used to calculate the mean value.  For example, a track
%       comprised of four data points with a mean value of 0.2 would be
%       represented as [0.2 0.2 0.2 0.2], while a track with only two data
%       points but a mean value of 0.15 would be represented as [0.15 0.15] 
%       for the WEIGHTED standard deviation calculation.
% 
%   example:
%       [ss,tt] = mwspeedmm(60, 960 ...
%           'G:\Data\Chris\2009_04_20\N2_day1.mat',...
%           'G:\Data\Chris\2009_04_21\N2_day2.mat',...
%           'G:\Data\Chris\2009_04_22\N2_day3.mat');
%       would combine all the multiple worm track recorded in those three
%       days' .mat files (each containing the necessary analyzed "Tracks"
%       structure into a single set of data, then find the mean speed
%       values for each 60-second period from the start of the first worm's
%       track through the end of the last worm's track.  The function
%       returns the speed and time values in ss and tt.  Speed data
%       recorded after 960 seconds into each recording is ignored.
%
% - Christopher J. Cronin  (cjc@caltech.edu)
%   California Institute of Technology
%   Sternberg Lab
%   Pasadena, CA  USA
%   April 22, 2009

% Created for speed decay vs time work by Meenakshi Doma.


% Initialize intermidiate/output vectors
tt = [];
ss = [];
tcell = {};
scell = {};

% Loop through each input .mat file
for j = 1:numel(varargin)   % 1:nargin-2
    t = [];
    s = [];
    
    % Place I/O stuff in try/catch statement for safety
    try
        load(varargin{j});
        
        if exist('Tracks', 'var') == 1  % Only care if Tracks is in the loaded .mat file
            for i = 1:numel(Tracks)
                % Trim off speed values recorded after cut-off time
                abridgedTime    = Tracks(i).Time;
                abridgedSpeed   = Tracks(i).Speed;
                abridgedSpeed   = abridgedSpeed(abridgedTime < cutoffTime);
                abridgedTime    = abridgedTime( abridgedTime < cutoffTime);
                
                t = [t abridgedTime];
                s = [s abridgedSpeed];

                % Collect time and speed vectors for each individual track
                % into time and speed cell arrays
                tcell{numel(tcell)+1} = abridgedTime;
                scell{numel(scell)+1} = abridgedSpeed;
                
            end
        else
            fprintf(1, 'No ''Tracks'' in %s.  Skipping...', varargin{j});
        end
        clear Tracks
        
        % Combine time and speed vectors
        tt = [tt, t];
        ss = [ss, s];
        
    catch ME
        fprintf(1, '%s\n', ME.message);
    end
    
end


% Sort speed data against by time
[tt, ix] = sort(tt);
ss = ss(ix);

% figure; plot(tt,ss, 'ro');

% Create time bins
ttt = tt/binsize;
ttt = floor(ttt)*binsize;
ttt = ttt+binsize;
bins = unique(ttt);

%------------------------------------------------------------------------
% Calculate statistics about sample sizes at each timepoint
uniqueTimepoints = unique(tt);
timepointsamplesizes = NaN*ones(size(uniqueTimepoints));
for k = 1:numel(uniqueTimepoints)
    timepointsamplesizes(k) = sum(tt == uniqueTimepoints(k));
end

% Combine timepoints into bins
meanBinnedTimepointSampleSize   = NaN*ones(size(bins));
maxBinnedTimepointSampleSize    = NaN*ones(size(bins));
minBinnedTimepointSampleSize    = NaN*ones(size(bins));

for k = 1:numel(bins)
    % figure out statistics for timepoints in each bin
    if k == 1
        meanBinnedTimepointSampleSize(k) = mean(timepointsamplesizes( uniqueTimepoints < bins(k)  ));
         maxBinnedTimepointSampleSize(k) =  max(timepointsamplesizes( uniqueTimepoints < bins(k)  ));
         minBinnedTimepointSampleSize(k) =  min(timepointsamplesizes( uniqueTimepoints < bins(k)  ));
    elseif k == numel(bins)
        meanBinnedTimepointSampleSize(k) = mean(timepointsamplesizes( uniqueTimepoints >=bins(k-1)));
         maxBinnedTimepointSampleSize(k) =  max(timepointsamplesizes( uniqueTimepoints >=bins(k-1)));
         minBinnedTimepointSampleSize(k) =  min(timepointsamplesizes( uniqueTimepoints >=bins(k-1)));
    else
        meanBinnedTimepointSampleSize(k) = mean(timepointsamplesizes((uniqueTimepoints >=bins(k-1)) & ...
                                                                     (uniqueTimepoints < bins(k)) ));
         maxBinnedTimepointSampleSize(k) =  max(timepointsamplesizes((uniqueTimepoints >=bins(k-1)) & ...
                                                                     (uniqueTimepoints < bins(k)) ));
         minBinnedTimepointSampleSize(k) =  min(timepointsamplesizes((uniqueTimepoints >=bins(k-1)) & ...
                                                                     (uniqueTimepoints < bins(k)) ));
    end
    
end
%------------------------------------------------------------------------

% Create and populate 3D matrix of mean speed data, with populations and stds
meandata = NaN*ones(numel(scell), numel(bins), 3);
startstop = NaN*ones(numel(scell), numel(bins), 2);
% Where,
% dimension 1: tracks
% dimension 2: time bins
% dimension 3: mean speeds, 
%               n (number of data points for track in bin),
%                std  (of data points for track in bin 


for i = 1:numel(scell)
    % Temporary vector identifying speeds/times with time bins
    tttcell = tcell{i}/binsize;
    tttcell = floor(tttcell)*binsize;
    tttcell = tttcell+binsize;
    
    for k = 1:numel(bins)
        meandata(i,k,1) =  mean(scell{i}(tttcell==bins(k)));
        meandata(i,k,2) = numel(scell{i}(tttcell==bins(k)));
        meandata(i,k,3) =   std(scell{i}(tttcell==bins(k)));
        
        if (any(~isnan(tcell{i}(tttcell==bins(k)))))
            startstop(i,k,1) =  min(tcell{i}(tttcell==bins(k)));
            startstop(i,k,2) =  max(tcell{i}(tttcell==bins(k)));
        end
    end
end


% Plain old mean speeds per bin
po_mean = nanmean(meandata(:,:,1));
 po_std =  nanstd(meandata(:,:,1));
   po_n = sum(~isnan(meandata(:,:,1)));

% Weighted Mean
weightedmean = nansum(meandata(:,:,1).*meandata(:,:,2))./nansum(meandata(:,:,2));
weightedstd = NaN*ones(size(bins)); % (see calculation below)
weightedn = NaN*ones(size(bins));   % Number of data points in bin
for k = 1:numel(bins)
    fauxspeed = [];
    for i = 1:size(meandata,1)
        if ~isnan(meandata(i,k,1))
            fauxspeed = [fauxspeed, meandata(i,k,1)*ones(1,meandata(i,k,2))];
        end
    end
    weightedstd(k) = std(fauxspeed);
    weightedn(k) = numel(fauxspeed);
end



% Format output
dataStruct.po_mean      = po_mean;
dataStruct.po_std       = po_std;
dataStruct.po_n         = po_n;
dataStruct.bins         = bins;
dataStruct.meandata     = meandata;
dataStruct.weightedmean = weightedmean;
dataStruct.weightedstd  = weightedstd;
dataStruct.weightedn    = weightedn;
dataStruct.ss           = ss;
dataStruct.tt           = tt;

return;

